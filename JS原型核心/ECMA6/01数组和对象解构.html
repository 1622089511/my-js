<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			//es5 :  var a = 1, b = 2, c= 3;
			//ES6:可以从数组中提取值，按照对应位置，对变量进行解构
				//基础用法
					let  [a,b,c] = [1,2,3];
					
					let[foo,[  [bar] , baz] ] = [1,[ [2],3]];
					console.log(foo);  //1
					
					let [x1, , y1] = ["foo","bar","baz"];
					console.log(x1);  //foo
					
					let [head,...tail] = [1,2,3,4];
					console.log(head); //1
					console.log(tail);    //[2,3,4]
					
					let[x,y,...z] = ['a'];
					console.log(x);	//a
					console.log(y);	//undefined
					console.log(z);	//[]
					
				//tips1:如果解构不成功，变量的值就等于undefined。	不完全解构,解构依然可以成功.
			
					let  [d] = [];
					console.log(d);	//undefined
					
					let [n1,n2] =[1];
					console.log(n1); 	 //1
					console.log(n2); 	//undefined
					
					let[s1,s2] = ["s1","s2","s3","s4"];
					console.log(s2); 	//s2
					
				//tip2:如果解构时候右侧不是数组直接报错
				
					/*	这里直接报错了,且影响其他解构
					 	let [foo] = 1;
						let [foo] = false;
						let [foo] = NaN;
						let [foo] = undefined;
						let [foo] = null;
						let [foo] = {}; 
					*/
				
				//tip3:对于Set数据结构，也可以解构。
						
					let [set1,set2,set3] = new Set([1,2,3]);
					console.log(set1);	//1
					
				//tip4:某种数据结构具有 Iterator 接口，例如Generator都可以采用数组形式的解构赋值	
					function* fibs() {
						  let a = 0;
						  let b = 1;
						  while (true) {
						    yield a;
						    [a, b] = [b, a + b];
						  }
						}
					let [first, second, third, fourth, fifth, sixth] = fibs();
					console.log(sixth);
					
				//各种用法：允许默认值,有默认值即默认。无默认解构数据按对应位置替换。
					let [q = true] = [];
					console.log(q)   //有默认值 true
					
					let[q1,q2 = 'b'] =['a'];
					console.log(q1,q2); //q1= a, q2 = b
					
					let [q3,q4='b'] = ['a','c'];
					console.log(q3,q4);  //q3 = b ,q4= c
					
					//null和undefined呢
					let[q5 = 1] = [undefined];
					console.log(q5);  //undefined不会赋值
					let[q6 = 1] = [null];
					console.log(q6); //null会赋值
				
				
					//函数会怎么样
					
					function q8(){console.log('function?')};
					let [q7 = q8()] = [1];     //1
					console.log(q7);			//因为q7能取到值,所以函数不会运行
					
					 // let[q9=q10,q10=10] = []; 
					// console.log(q9) 报错q10还没定义就引用,因为没变量提升
					
			//对象的解构
				//对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；
				//而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
					let { o1 , o2 } = {
						o1 : 'foo',
						o2: 'bar'
					}
					console.log(o1,o2); //foo,bar
					//这样会取不到对象
					let {o3} = {
						attr1:'24',
						attr2:'no'
					}
					console.log(o3); //undefined 
					
				//如果变量名和属性名不一致，解构参数要用：
					let {o4:o5} = {
						o4: 'aaa', o5:'bbb'			//o5 = 'bbb' , o5 = 'aaa'
					}
					console.log(o5); //aaa         先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。
				//例子	
					let obj ={																							//     var obj = { first: 'hello', last: 'world' }
						first : 'hello', last: 'world'																//		var f = obj.first;
					};																	//   对应的es5 =>		//		var l = obj.last;
					let{first : f ,last : l} = obj;																	//     console.log(obj.f,obj.l)
					console.log(f+','+l)		//hello,world
				//所以对象的解构实际上是被赋值的是f和l，f和l是匹配模式，first和last是参数
				//对于let和const不能重复声明，所以需要注意
					
				
				//嵌套解构
				let obj2 = {
					p:[
						'hello',
						{ oy:'World' }
					]
				};
				let {
					p:[ox,{oy}]
				}=obj2;
				console.log(ox , oy); //hello world
				
				
		</script>
	</body>
</html>
